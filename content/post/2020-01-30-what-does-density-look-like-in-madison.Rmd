---
title: What Does Density Look Like in Madison?
author: Harald Kliems
date: '2020-01-30'
slug: what-does-density-look-like-in-madison
categories: []
tags:
  - landuse
  - Madison
  - R
draft: true  
---
This is a follow-up to my previous post on *where* Madison is most dense. But what do these dense areas look like? Inspired by the ["Every Lot" bot]( http://fakeisthenewreal.org/everylot/), I'll use the Google Street View API via the `googleway` package to (hopefully) create some visual sense of density. 
```{r}
## Code from previous post to get 10 most dense block groups in Dane County
library(sf)
library(tidycensus)
library(tidyverse)
library(ggplot2)
library(leaflet)
library(googleway)
key <- Sys.getenv("STREET_VIEW_API_KEY") #key requires a credit card on file

pop <- get_acs(geography = "block group", 
                     variables = "B01003_001", 
                     state = "WI",
                     county = "Dane",
                     geometry = TRUE,
                     keep_geo_vars = TRUE)
pop2 <- pop %>% 
  mutate(pop_density = estimate / (ALAND /27878400)) %>%  #create variable for population density
  drop_na %>%
  filter(pop_density > 100000) %>% 
  arrange(desc(pop_density))                     
```

A good starting point for exploration would be the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_polygon) of the block group. Block groups can have odd shapes, though, which can lead to the true centroid ending up outside the polygon. I'll use `st_point_on_surface` instead.

```{r}
pop2 <- pop2 %>% 
  mutate(center = st_point_on_surface(geometry))
```
A quick visual check:
```{r}
library(ggmap)
ggplot(data = pop2) +
  geom_sf(aes(fill = pop_density), 
          alpha = 0.5,
          color = NA) +
  geom_sf(aes(geometry = center))
```
Looks good! Now let's get Street View images. Testing with the first row:

```{r}
google_streetview(location = st_coordinates(pop2$center[1]),
    size = c(400,400), output = "plot",
    key = key)
```
"No imagery here" -- that's because lat/lon are in the reverse order! I'll fix this, and in order to save API calls I'll also turn on the `response_check` option in `google_streetview`
```{r}
google_streetview(location =  c(st_coordinates(pop2$center[1])[2],
                                st_coordinates(pop2$center[1])[1]),
    size = c(400,400), 
    output = "plot",
    response_check = TRUE,
    key = key)
```
Still no luck. What apparently is going on is that there is no Street View imagery at the *exact* coordinates -- which isn't too surprising that the coordinates are just some point inside a block group and not necessarily on or near a street. The Every Lot project doesn't have this issue, as per definition a lot has a street address. A couple ideas to resolve the problem:

* rounding the coordinates to a less precise location may make this more forgiving
* reverse-geocode the coordinates with something like the Census Geocoder to obtain street addresses

The first option is easier to implement and I'll try it out first. This [XKCD comic](https://www.explainxkcd.com/wiki/index.php/2170:_Coordinate_Precision) helps figure out how much rounding is needed:

![XKCD comic on coordinate precision(https://www.explainxkcd.com/wiki/images/8/88/coordinate_precision.png)

"A specific suburban cul-de-sac"-level accuracy with 3 digits sounds good.

```{r}
google_streetview(location =  round(c(st_coordinates(pop2$center[1])[2],
                                st_coordinates(pop2$center[1])[1]), 3),
    size = c(1000,400), 
    fov = 120,
    output = "plot",
    response_check = TRUE,
    key = key)
```
Great, it works! I also adjusted the `fov` (field of view) to 120 degrees in order to get as much context as possible in the image.

```{r}
# markers and paths are easy to access
d <- function(x=-95.36, y=29.76, n,r,a){
  round(data.frame(
    lon = jitter(rep(x,n), amount = a),
    lat = jitter(rep(y,n), amount = a)
  ), digits = r)
}
df <- d(n=50,r=3,a=.3)
map <- get_googlemap(markers = df, path = df, scale = 2, key = key)
ggmap(map)
ggmap(map, extent = "device") +
  geom_point(aes(x = lon, y = lat), data = df, size = 3, colour = "black") +
  geom_path(aes(x = lon, y = lat), data = df)


ggmap(get_googlemap(center = c(43.071489,-89.3983367307066), color = "bw", scale = 2, key = key), extent = "device")
```



